
class Object
  
  # checks weather two objects have the same values for __equal_attributes__
  #
  def has_equal_attributes?(equal_attributes, object)
    equal_attributes.each{ |a| return false if send(a) != object.send(a) }
    return true
  end
  
end

# = Reports::Util
#
# utilities
#
class Reports::Util
  
  # groups attributes the into groups with equal values for __equal_attributes__, returns an array with sub-arrays for each group  
  # * see Reports::UtilTest for an example
  #
  # call-seq:
  #   self.group( objects, equal_attributes ) => array
  #
  def self.group( objects, equal_attributes )
    
    result = Array.new
    
    objects.each do |o|
      
      match = false
      result.each do |r|
        if o.has_equal_attributes?(equal_attributes, r[0])
          match = true
          r.push(o)
          break
        end
      end
      
      if !match
        result.push(Array.new)
        result[-1].push(o)
      end
    end
    
    return result    
  end
  
  # checks weather all groups in a grouping (generated by self.group) have have corresponding objects
  # * i.e. for each object in a group, there must be a object in each other group that has equal values for __match_attributes__
  # * see Reports::UtilTest for an example
  # * raises exception if no matching
  #
  # call-seq:
  #   self.check_group_matching( grouped_objects, match_attributes )
  #
  def self.check_group_matching( grouped_objects, match_attributes )
    
    raise "less then 2 groups, no matching possible" if grouped_objects.size<2
    first_group = grouped_objects[0]
    other_groups = grouped_objects[1..-1].collect{ |g| g.collect{|o| o }} 
    other_groups.each{ |g| raise "groups are not equally sized, matching impossible" if g.size != first_group.size } 
    
    first_group.each do |o|
      
      #puts "match "+o.to_s
      other_groups.each do |group|
        
        match = false  
        group.each do |o2|
          #puts "try "+o2.to_s
          if o.has_equal_attributes?(match_attributes, o2)
            match = true
            group.delete(o2)
            break
          end
        end
        raise "no match found for "+o.to_s unless match
      end
    end
  end
  
  # returns the path of a file in directory ENV['TMP_DIR'], beginning with __tmp_file_name__, that does not exist yet 
  #
  # call-seq:
  #   self.create_tmp_file(tmp_file_name) => string
  #
  def self.create_tmp_file(tmp_file_name)

    tmp_file_path = nil
    while (!tmp_file_path || File.exist?(tmp_file_path) )
      tmp_file_path = ENV['TMP_DIR']+"/#{tmp_file_name}.#{Time.now.strftime("%Y-%-m-%d_%M-%S")}.#{rand(11111).to_s}"
    end
    return tmp_file_path
  end

end